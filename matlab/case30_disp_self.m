function mpc = case30_disp_self
%T_AUCTION_CASE    Power flow data for testing auction code.
%   Please see CASEFORMAT for details on the case file format.

%   MATPOWER       

% [PQ, PV, REF, NONE, BUS_I, BUS_TYPE, PD, QD, GS, BS, BUS_AREA, VM, ...
%     VA, BASE_KV, ZONE, VMAX, VMIN, LAM_P, LAM_Q, MU_VMAX, MU_VMIN] = idx_bus;
% [GEN_BUS, PG, QG, QMAX, QMIN, VG, MBASE, GEN_STATUS, PMAX, PMIN, ...
%     MU_PMAX, MU_PMIN, MU_QMAX, MU_QMIN, PC1, PC2, QC1MIN, QC1MAX, ...
%     QC2MIN, QC2MAX, RAMP_AGC, RAMP_10, RAMP_30, RAMP_Q, APF] = idx_gen;
% [PW_LINEAR, POLYNOMIAL, MODEL, STARTUP, SHUTDOWN, NCOST, COST] = idx_cost;
% [QUANTITY, PRICE, FCOST, VCOST, SCOST, PENALTY] = idx_disp;

%%-----  Power Flow Data  -----%%
%% system MVA base
mpc.version = '2';
mpc.baseMVA = 100;

%本文从t_auction_case修改过来
%% bus data
%Pd就表示了这个节点上的负荷，相当于load了,这些load都是固定load，要将其转为可变的（比如线性需求曲线）,可以将该节点的load变0，然后在gen中加入可调度负荷，具体实现可以直接使用内置函数mpc = loadcase('case9');   mpc = load2disp(mpc, 'l', 'pwl', [], 0);
% 1PQ节点：也称为负荷节点(两个都没定义为PQ)，该节点的电压和相位是未知的，负载的有功和无功都是已知的，因此需要通过潮流计算来求解该节点的电压和相位。
% 2PV节点：也称为发电节点（两个都有定义为PV），该节点的电压幅值是已知的，有功和无功都是未知的，因此需要通过潮流计算来求解有功和无功。
% 3REF节点：也称为基准节点，该节点的电压幅值和相位都是已知的，通常用于设定电网电压的基准值。
%	bus_i	type	Pd	Qd	Gs	Bs	area	Vm	Va	baseKV	zone	Vmax	Vmin
mpc.bus = [ %未修改
	1	3	0	0	0	0	1	1	0	135	1	1.05	0.95;
	2	2	5.04485072	2.95251632	0	0	1	1	0	135	1	1.1	0.95;
	3	1	22.3182336	11.1591168	0	0	1	1	0	135	1	1.05	0.95;
	4	1	8.8343008	1.8598528	0	0	1	1	0	135	1	1.05	0.95;
	5	1	0	0	0	0.19	1	1	0	135	1	1.05	0.95;
	6	1	0	0	0	0	1	1	0	135	1	1.05	0.95;
	7	2	0	0	0	0	1	1	0	135	1	1.05	0.95;
	8	1	13.948896	13.948896	0	0	1	1	0	135	1	1.05	0.95;
	9	1	0	0	0	0	1	1	0	135	1	1.05	0.95;
	10	1	6.7419664	2.324816	0	0	3	1	0	135	1	1.05	0.95;
	11	1	0	0	0	0	1	1	0	135	1	1.05	0.95;
	12	1	13.0189696	8.71806	0	0	2	1	0	135	1	1.05	0.95;
	13	2	0	0	0	0	2	1	0	135	1	1.1	0.95;
	14	1	7.2069296	1.8598528	0	0	2	1	0	135	1	1.05	0.95;
	15	2	0	0	0	0	2	1	0	135	1	1.05	0.95;
	16	1	4.068428	2.0923344	0	0	2	1	0	135	1	1.05	0.95;
	17	1	10.461672	6.7419664	0	0	2	1	0	135	1	1.05	0.95;
	18	1	3.7197056	1.0461672	0	0	2	1	0	135	1	1.05	0.95;
	19	1	11.042876	3.9521872	0	0	2	1	0	135	1	1.05	0.95;
	20	1	2.5572976	0.8136856	0	0	2	1	0	135	1	1.05	0.95;
	21	1	3.39036344738	2.1698326063232	0	0	3	1	0	135	1	1.05	0.95;
% 	220	2	0	0	0	0	3	1	0	135	1	1.1	0.95;
    22	2	0	0	0	0	3	1	0	135	1	1.1	0.95;
	23	2	22.3182336	11.1591168	0	0	2	1	0	135	1	1.1	0.95;
	24	1	10.1129496	7.7881336	0	0.04	3	1	0	135	1	1.05	0.95;
	25	1	0	0	0	0	3	1	0	135	1	1.05	0.95;
	26	1	4.068428	2.6735384	0	0	3	1	0	135	1	1.05	0.95;
	27	2	0	0	0	0	3	1	0	135	1	1.1	0.95;
	28	1	0	0	0	0	1	1	0	135	1	1.05	0.95;
	29	1	2.7897792	1.0461672	0	0	3	1	0	135	1	1.05	0.95;
	30	2	0	0	0	0	3	1	0	135	1	1.05	0.95;
];
% mpc.bus = [
% 	1	3	0	0	0	0	1	1	0	230	1	1.05	0.95;
% 	2	2	5.04485072	0	0	0	1	1	0	230	1	1.1	0.95;
% 	3	1	22.3182336	0	0	0	1	1	0	230	1	1.05	0.95;
% 	4	1	8.8343008	0	0	0	1	1	0	230	1	1.05	0.95;
% 	5	1	0	0	0	0.19	1	1	0	230	1	1.05	0.95;
% 	6	1	0	0	0	0	1	1	0	230	1	1.05	0.95;
% 	7	2	0	0	0	0	1	1	0	230	1	1.05	0.95;
% 	8	1	13.948896	13.948896	0	0	1	1	0	230	1	1.05	0.95;
% 	9	1	0	0	0	0	1	1	0	230	1	1.05	0.95;
% 	10	1	6.7419664	2.324816	0	0	3	1	0	230	1	1.05	0.95;
% 	11	1	0	0	0	0	1	1	0	230	1	1.05	0.95;
% 	12	1	13.0189696	8.71806	0	0	2	1	0	230	1	1.05	0.95;
% 	13	2	0	0	0	0	2	1	0	230	1	1.1	0.95;
% 	14	1	7.2069296	1.8598528	0	0	2	1	0	230	1	1.05	0.95;
% 	15	2	0	0	0	0	2	1	0	230	1	1.05	0.95;
% 	16	1	4.068428	2.0923344	0	0	2	1	0	230	1	1.05	0.95;
% 	17	1	10.461672	6.7419664	0	0	2	1	0	230	1	1.05	0.95;
% 	18	1	3.7197056	1.0461672	0	0	2	1	0	230	1	1.05	0.95;
% 	19	1	11.042876	3.9521872	0	0	2	1	0	230	1	1.05	0.95;
% 	20	1	2.5572976	0.8136856	0	0	2	1	0	230	1	1.05	0.95;
% 	21	1	3.39036344738	2.1698326063232	0	0	3	1	0	230	1	1.05	0.95;
% 	220	2	0	0	0	0	3	1	0	230	1	1.1	0.95;
% 	23	2	22.3182336	11.1591168	0	0	2	1	0	230	1	1.1	0.95;
% 	24	1	10.1129496	7.7881336	0	0.04	3	1	0	230	1	1.05	0.95;
% 	25	1	0	0	0	0	3	1	0	230	1	1.05	0.95;
% 	26	1	4.068428	2.6735384	0	0	3	1	0	230	1	1.05	0.95;
% 	27	2	0	0	0	0	3	1	0	230	1	1.1	0.95;
% 	28	1	0	0	0	0	1	1	0	230	1	1.05	0.95;
% 	29	1	2.7897792	1.0461672	0	0	3	1	0	230	1	1.05	0.95;
% 	30	2	0	0	0	0	3	1	0	230	1	1.05	0.95;
% ];
% 在MATPOWER中，mpc.bus的每一列表示如下内容：
% bus_i：节点编号（int型）
% type：节点类型，取值为1、2或3，分别表示平衡节点、PV节点或PQ节点（int型）
% Pd：节点有功负荷（float型，单位为MW）
% Qd：节点无功负荷（float型，单位为MVar）
% Gs：节点有功支路导纳的实部（float型，单位为MW）
% Bs：节点无功支路导纳的虚部（float型，单位为MVar）
% area：节点所属区域（int型）
% Vm：节点电压幅值（float型，单位为p.u.）
% Va：节点电压相角（float型，单位为degree）
% baseKV：节点基准电压（float型，单位为kV）
% zone：节点所属电压等级区域（int型）
% Vmax：节点电压上限（float型，单位为p.u.）
% Vmin：节点电压下限（float型，单位为p.u.）
%% generator data
% has 9 generators, where the last three have negative PMIN to model the dispatchable loads.
% 前6行是发电商，后3行是可调度负荷，即售电商(因为能参与竞价)。   可调度负荷（dispatchable load）是指可以通过ISO进行调度的负荷，包括工业负荷、商业负荷、家庭负荷等。这些负荷可以根据市场需求、电网状态等因素进行灵活的调度。售电商可以被视为可调度负荷的一种，因为他们可以向ISO报价报量，并接受ISO的调度指令来调整其负荷。
% 将发电商和售电商一起存储在gen里面！！！666
% 第二列Pg，是初始有功出力，实际求解过程不太重要，会作为优化问题的起始点提供给优化器，不影响最终结果，但可能影响收敛速度。但是某些情形会用到：这是因为如果系统中没有足够的可调度发电容量，ISO可能需要调整系统的负荷来满足稳定性和供需平衡。在这种情况下，ISO会使用mpc.gen中的Pg列来指示哪些发电机应该按预设定值运行，哪些应该减少输出以保持稳定。此外，在某些情况下，ISO可能需要对发电机的出力进行调整，以满足网络规则和市场要求，这也需要使用mpc.gen中的Pg列。因此，即使发电商进行报价报量，mpc.gen(:,2)仍然是一个重要的变量。
%	bus	Pg	Qg	Qmax	Qmin	Vg	mBase	status	Pmax	Pmin
mpc.gen = [ %bus中的固定负荷差不多150
% 	1	23.54	0	60	-15	1	100	1	30	0; %30
% 	2	60.97	0	60	-15	1	100	1	60	0;
% 	220	21.59	0	60	-15	1	100	1	150	0; %60  120
% 	27	26.91	0	60	-15	1	100	1	100	0; %60
% 	23	19.2	0	60	-15	1	100	1	160	0; %60  30
% 	13	37	0	60	-15	1	100	1	60	0;
    
    1	23.54	0	60	-15	1	100	1	100	0; %30
	2	60.97	0	60	-15	1	100	1	80	0;
% 	220	21.59	0	60	-15	1	100	1	80	0; %60  120
    22	21.59	0	60	-15	1	100	1	80	0; %60  120
	27	26.91	0	60	-15	1	100	1	120	0; %60
	23	19.2	0	60	-15	1	100	1	50	0; %60  30
	13	37	0	60	-15	1	100	1	50	0;
    
	7	-30	-15	0	-15	1	100	1	0	-60; %30   60    这里python那边设置了自动传入最大需求量
	15	-30	-12	0	-12	1	100	1	0	-100; %30   120
	30	-10	-2.5	0	-7.5	1	100	1	0	-80;
    
%     7	-30	-15	0	-15	1	100	1	0	-35; %30   60    这里python那边设置了自动传入最大需求量
% 	15	-30	-12	0	-12	1	100	1	0	-60; %30   120
% 	30	-10	-2.5	0	-7.5	1	100	1	0	-50;

% 	7	-30	-15	0	-15	1	100	1	0	-60; %30   60
% 	15	-30	-12	0	-12	1	100	1	0	-100; %30   120
% 	30	-10	-2.5	0	-7.5	1	100	1	0	-80;
];
% mpc.gen = [
% 	1	20	0	0	0	1	100	1	60	0;
% 	2	20	0	0	0	1	100	1	60	0;
% 	220	20	0	0	0	1	100	1	60	0;
% 	27	20	0	0	0	1	100	1	60	0;
% 	23	20	0	0	0	1	100	1	60	0;
% 	13	20	0	0	0	1	100	1	60	0;
% 	7	-15   0	0	0	1	100	1	0	-30;
% 	15	-15   0	0	0	1	100	1	0	-30;
% 	30	-15   0	0	0	1	100	1	0	-30; %只要满足gen(:, PMIN) < 0 & gen(:, PMAX) == 0;，优化过程中的isload函数就会判断这个gen其实是个dispatchable
% ];

%% branch data
%	fbus	tbus	r	x	b	rateA	rateB	rateC	ratio	angle	status
% mpc.branch = [
% 	1	2	0.02	0.06	0.03	130	130	130	0	0	1; %不能全都让A个BC相等否则不容易收敛
% 	1	3	0.05	0.19	0.02	130	130	130	0	0	1;
% 	2	4	0.06	0.17	0.02	65	65	65	0	0	1;
% 	3	4	0.01	0.04	0	130	130	130	0	0	1;
% 	2	5	0.05	0.2	0.02	130	130	130	0	0	1;
% 	2	6	0.06	0.18	0.02	65	65	65	0	0	1;
% 	4	6	0.01	0.04	0	90	90	90	0	0	1;
% 	5	7	0.05	0.12	0.01	70	70	70	0	0	1;
% 	6	7	0.03	0.08	0.01	130	130	130	0	0	1;
% 	6	8	0.01	0.04	0	32	32	32	0	0	1;
% 	6	9	0	0.21	0	65	65	65	0	0	1;
% 	6	10	0	0.56	0	32	32	32	0	0	1;
% 	9	11	0	0.21	0	65	65	65	0	0	1;
% 	9	10	0	0.11	0	65	65	65	0	0	1;
% 	4	12	0	0.26	0	65	65	65	0	0	1;
% 	12	13	0	0.14	0	65	65	65	0	0	1;
% 	12	14	0.12	0.26	0	10000	32	32	0	0	1;
% 	12	15	0.07	0.13	0	32	32	32	0	0	1;
% 	12	16	0.09	0.2	0	32	32	32	0	0	1;
% 	14	15	0.22	0.2	0	16	16	16	0	0	1;
% 	16	17	0.08	0.19	0	16	16	16	0	0	1;
% 	15	18	0.11	0.22	0	10000	16	16	0	0	1;
% 	18	19	0.06	0.13	0	16	16	16	0	0	1;
% 	19	20	0.03	0.07	0	32	32	32	0	0	1;
% 	10	20	0.09	0.21	0	10000	32	32	0	0	0;
% 	10	17	0.03	0.08	0	32	32	32	0	0	0;
% 	10	21	0.03	0.07	0	10000	32	32	0	0	1;
% 	10	220	0.07	0.15	0	10000	32	32	0	0	1;
% 	21	220	0.01	0.02	0	32	32	32	0	0	1;
% 	15	23	0.1	0.2	0	16	16	16	0	0	1;
% 	220	24	0.12	0.18	0	10000	16	16	0	0	1;
% 	23	24	0.13	0.27	0	10	16	16	0	0	1;
% 	24	25	0.19	0.33	0	16	16	16	0	0	1;
% 	25	26	0.25	0.38	0	16	16	16	0	0	1;
% 	25	27	0.11	0.21	0	10000	16	16	0	0	1;
% 	28	27	0	0.4	0	10000	65	65	0	0	1;
% 	27	29	0.22	0.42	0	10000	16	16	0	0	1;
% 	27	30	0.32	0.6	0	10000	16	16	0	0	1;
% 	29	30	0.24	0.45	10000	16	16	16	0	0	1;
% 	8	28	0.06	0.2	0.02	32	32	32	0	0	1;
% 	6	28	0.02	0.06	0.01	32	32	32	0	0	1;
% ];
% mpc.branch = [
% 	1	2	0.02	0.06	0.03	10000	130	130	0	0	1;   %这些130 65啥的容量，早就超过了一个节点成交的最大量了（各种负荷最大基本就30），所以要想阻塞，最好设点低于30的容量
% 	1	3	0.05	0.19	0.02	30	30	30	0	0	1;
% 	2	4	0.06	0.17	0.02	10000	65	65	0	0	1;
% 	3	4	0.01	0.04	0	10000	130	130	0	0	1;
% 	2	5	0.05	0.2	0.02	10000	130	130	0	0	1;
% 	2	6	0.06	0.18	0.02	10000	65	65	0	0	1;
% 	4	6	0.01	0.04	0	10000	90	90	0	0	1;
% 	5	7	0.05	0.12	0.01	30	30	30	0	0	1;
% 	6	7	0.03	0.08	0.01	10000	130	130	0	0	1;
% 	6	8	0.01	0.04	0	10000	32	32	0	0	1;
% 	6	9	0	0.21	0	10000	65	65	0	0	1;
% 	6	10	0	0.56	0	10000	32	32	0	0	1;
% 	9	11	0	0.21	0	10000	65	65	0	0	1;
% 	9	10	0	0.11	0	10000	65	65	0	0	1;
% 	4	12	0	0.26	0	10	10	10	0	0	1;
% 	12	13	0	0.14	0	10000	65	65	0	0	1;
% 	12	14	0.12	0.26	0	10000	32	32	0	0	1;
% 	12	15	0.07	0.13	0	10000	32	32	0	0	1;
% 	12	16	0.09	0.2	0	10000	32	32	0	0	1;
% 	14	15	0.22	0.2	0	16	16	16	0	0	1;
% 	16	17	0.08	0.19	0	10000	16	16	0	0	1;
% 	15	18	0.11	0.22	0	10000	16	16	0	0	1;
% 	18	19	0.06	0.13	0	10000	16	16	0	0	1;
% 	19	20	0.03	0.07	0	10000	32	32	0	0	1;
% 	10	20	0.09	0.21	0	10000	32	32	0	0	0;
% 	10	17	0.03	0.08	0	10000	32	32	0	0	0;
% 	10	21	0.03	0.07	0	10000	32	32	0	0	1;
% 	10	220	0.07	0.15	0	10000	32	32	0	0	1;
% 	21	220	0.01	0.02	0	10000	32	32	0	0	1;
% 	15	23	0.1	0.2	0	10000	16	16	0	0	1;
% 	220	24	0.12	0.18	0	10000	16	16	0	0	1;
% 	23	24	0.13	0.27	0	10	16	16	0	0	1;
% 	24	25	0.19	0.33	0	10000	16	16	0	0	1;
% 	25	26	0.25	0.38	0	10000	16	16	0	0	1;
% 	25	27	0.11	0.21	0	10000	16	16	0	0	1;
% 	28	27	0	0.4	0	10000	65	65	0	0	1;
% 	27	29	0.22	0.42	0	10000	16	16	0	0	1;
% 	27	30	0.32	0.6	0	10000	16	16	0	0	1;
% 	29	30	0.24	0.45	0	10000	16	16	0	0	1;
% 	8	28	0.06	0.2	0.02	10000	32	32	0	0	1;
% 	6	28	0.02	0.06	0.01	10000	32	32	0	0	1;
% ];
mpc.branch = [
	1	2	0.02	0.06	0.03	0	0	0	0	0	1;   %这些130 65啥的容量，早就超过了一个节点成交的最大量了（各种负荷最大基本就30），所以要想阻塞，最好设点低于30的容量
	1	3	0.05	0.19	0.02	0	0	0	0	0	1;
	2	4	0.06	0.17	0.02	45	45	45	0	0	1;
	3	4	0.01	0.04	0	0	0	0	0	0	1;
	2	5	0.05	0.2	0.02	0	0	0	0	0	1;
	2	6	0.06	0.18	0.02	0	0	0	0	0	1;
	4	6	0.01	0.04	0	0	0	0	0	0	1;
	5	7	0.05	0.12	0.01	30	30	30	0	0	1;
	6	7	0.03	0.08	0.01	0	0	0	0	0	1;
	6	8	0.01	0.04	0	0	0	0	0	0	1;
	6	9	0	0.21	0	0	0	0	0	0	1;
	6	10	0	0.56	0	0	0	0	0	0	1;
	9	11	0	0.21	0	0	0	0	0	0	1;
	9	10	0	0.11	0	0	0	0	0	0	1;
	4	12	0	0.26	0	30	30	30	0	0	1;
	12	13	0	0.14	0	0	0	0	0	0	1;
	12	14	0.12	0.26	0	0	0	0	0	0	1;
	12	15	0.07	0.13	0	0	0	0	0	0	1;
	12	16	0.09	0.2	0	0	0	0	0	0	1;
	14	15	0.22	0.2	0	32	32	32	0	0	1;
	16	17	0.08	0.19	0	0	0	0	0	0	1;
	15	18	0.11	0.22	0	0	0	0	0	0	1;
	18	19	0.06	0.13	0	0	0	0	0	0	1;
	19	20	0.03	0.07	0	0	0	0	0	0	1;
	10	20	0.09	0.21	0	0	0	0	0	0	0;
	10	17	0.03	0.08	0	0	0	0	0	0	0;
	10	21	0.03	0.07	0	0	0	0	0	0	1;
% 	10	220	0.07	0.15	0	0	0	0	0	0	1;
    10	22	0.07	0.15	0	0	0	0	0	0	1;
% 	21	220	0.01	0.02	0	0	0	0	0	0	1;
    21	22	0.01	0.02	0	0	0	0	0	0	1;
	15	23	0.1	0.2	0	0	0	0	0	0	1;
% 	220	24	0.12	0.18	0	0	0	0	0	0	1;
    22	24	0.12	0.18	0	0	0	0	0	0	1;
	23	24	0.13	0.27	0	0	0	0	0	0	1;
	24	25	0.19	0.33	0	0	0	0	0	0	1;
	25	26	0.25	0.38	0	0	0	0	0	0	1;
	25	27	0.11	0.21	0	0	0	0	0	0	1;
	28	27	0	0.4	0	0	0	0	0	0	1;
	27	29	0.22	0.42	0	0	0	0	0	0	1;
	27	30	0.32	0.6	0	0	0	0	0	0	1;
	29	30	0.24	0.45	0	64	64	64	0	0	1;
	8	28	0.06	0.2	0.02	0	0	0	0	0	1;
	6	28	0.02	0.06	0.01	0	0	0	0	0	1;
];
% mpc.branch = [
% 	1	2	0.02	0.06	0.03	130	130	130	0	0	1;
% 	1	3	0.05	0.19	0.02	130	130	130	0	0	1;
% 	2	4	0.06	0.17	0.02	65	65	65	0	0	1;
% 	3	4	0.01	0.04	0	130	130	130	0	0	1;
% 	2	5	0.05	0.2	0.02	130	130	130	0	0	1;  %原本rateA全是10000，这样出来是统一出清价，不知道为啥
% 	2	6	0.06	0.18	0.02	65	65	65	0	0	1;
% 	4	6	0.01	0.04	0	90	90	90	0	0	1;
% 	5	7	0.05	0.12	0.01	70	70	70	0	0	1;
% 	6	7	0.03	0.08	0.01	10000	130	130	0	0	1;
% 	6	8	0.01	0.04	0	32	32	32	0	0	1;
% 	6	9	0	0.21	0	65	65	65	0	0	1;
% 	6	10	0	0.56	0	32	32	32	0	0	1;
% 	9	11	0	0.21	0	10000	65	65	0	0	1;
% 	9	10	0	0.11	0	65	65	65	0	0	1;
% 	4	12	0	0.26	0	65	65	65	0	0	1;
% 	12	13	0	0.14	0	65	65	65	0	0	1;
% 	12	14	0.12	0.26	0	32	32	32	0	0	1;
% 	12	15	0.07	0.13	0	32	32	32	0	0	1;
% 	12	16	0.09	0.2	0	32	32	32	0	0	1;
% 	14	15	0.22	0.2	0	16	16	16	0	0	1;
% 	16	17	0.08	0.19	0	16	16	16	0	0	1;
% 	15	18	0.11	0.22	0	16	16	16	0	0	1;
% 	18	19	0.06	0.13	0	16	16	16	0	0	1;
% 	19	20	0.03	0.07	0	32	32	32	0	0	1;
% 	10	20	0.09	0.21	0	32	32	32	0	0	0;
% 	10	17	0.03	0.08	0	32	32	32	0	0	0;
% 	10	21	0.03	0.07	0	32	32	32	0	0	1;
% 	10	220	0.07	0.15	0	32	32	32	0	0	1;
% 	21	220	0.01	0.02	0	32	32	32	0	0	1;
% 	15	23	0.1	0.2	0	16	16	16	0	0	1;
% 	220	24	0.12	0.18	0	16	16	16	0	0	1;
% 	23	24	0.13	0.27	0	16	16	16	0	0	1;
% 	24	25	0.19	0.33	0	16	16	16	0	0	1;
% 	25	26	0.25	0.38	0	16	16	16	0	0	1;
% 	25	27	0.11	0.21	0	16	16	16	0	0	1;
% 	28	27	0	0.4	0	65	65	65	0	0	1;
% 	27	29	0.22	0.42	0	16	16	16	0	0	1;
% 	27	30	0.32	0.6	0	16	16	16	0	0	1;
% 	29	30	0.24	0.45	0	16	16	16	0	0	1;
% 	8	28	0.06	0.2	0.02	32	32	32	0	0	1;
% 	6	28	0.02	0.06	0.01	32	32	32	0	0	1;
% ];

%%-----  OPF Data  -----%%
%% area data
%	area	refbus
% areas = [ %有影响，比如对节点电价有影响
% 	1	8;
% 	2	23;
% 	3	26;
% ];
%mpc.areas是MATPOWER中存储电力系统分区信息的一个矩阵。它的每一行代表一个分区，每一列存储不同的属性。常见的属性包括分区编号、分区名称、分区的最大功率范围等。 mpc.areas通常用于描述电力系统中不同的控制区域，以便进行分区控制和分析。
% 在 mpc.areas 中，每一行表示一个区域，包括两列，分别为：
% 第一列表示区域的编号；
% 第二列表示该区域的参考母线(bus)的标号。
% 例如，在你提供的示例中，共有3个区域，第一个区域的参考母线为8号母线，第二个区域的参考母线为23号母线，第三个区域的参考母线为26号母线。
% 如果整个系统只有一个区域和一个参考节点，可以将 mpc.areas 修改为如下形式：
% areas = [
%     1   1;
% ];
% 这表示整个系统属于一个区域，参考节点为1号节点。
%% generator cost data
%	1	startup	shutdown	n	x1	y1	...	xn	yn  分段线性成本函数
%	2	startup	shutdown	n	c(n-1)	...	c0   多项式成本函数
% 注意，矩阵的列顺序并非是smartmkt中使用的：[PW_LINEAR, POLYNOMIAL, MODEL, STARTUP, SHUTDOWN, NCOST, COST] = idx_cost;

% 前6行是发电机，后三行是可调节负荷
% mpc.gencost = [
% 	2	0	0	3   0.125	18  0; %注意写法，多余的0，补在后面，这里是12x+1200	0	0	4	0	0	12	240	36	1200	60	2400;
% 	2	0	0	3	0.100	20	0;
% 	2	0	0	3	0.100	25	0;
% 	2	0	0	3	0.100	22	0;
% 	2	0	0	3	0.100	22	0;
% 	2	0	0	3	0.125	16	0;
% 	2	0	0	3	-2.5	100	0;
% 	2	0	0	3	-2.5	70  0;
% 	2	0	0	3	-2.0	120	0;
% ];
mpc.gencost = [
% 	2	0	0	3   0.0125	18  0; %注意写法，多余的0，补在后面，这里是12x+1200	0	0	4	0	0	12	240	36	1200	60	2400;
% 	2	0	0	3	0.0100	20	0;
% 	2	0	0	3	0.0100	25	0;
% 	2	0	0	3	0.0100	22	0;
% 	2	0	0	3	0.0100	22	0;
% 	2	0	0	3	0.0125	16	0;
    
    2	0	0	3   0.125	18  0; %注意写法，多余的0，补在后面，这里是12x+1200	0	0	4	0	0	12	240	36	1200	60	2400;
	2	0	0	3	0.100	20	0;
	2	0	0	3	0.100	22	0;
	2	0	0	3	0.125	16	0;
	2	0	0	3	0.100	22	0;
	2	0	0	3	0.100	25	0;
    
% 	2	0	0	3	-0.25	100	0; %这样设置跟t_auction_case相近
% 	2	0	0	3	-0.25	90  0; %70 ，70的话这个load很难成交
% 	2	0	0	3	-0.20	120	0;

    
%     2	0	0	3	-0.025	50	0; 
% 	2	0	0	3	-0.025	45  0;
% 	2	0	0	3	-0.020	60	0;

% 	2	0	0	3	-0.15	80	0; 
% 	2	0	0	3	-0.10	90  0; 
% 	2	0	0	3	-0.13	85	0;
    
%     2	0	0	3	-0.15	70	0; 
% 	2	0	0	3	-0.10	80  0; 
% 	2	0	0	3	-0.13	75	0;
    
    2	0	0	3	0.15	70	0; 
	2	0	0	3	0.10	80  0; 
	2	0	0	3	0.13	75	0;
    
%     2	0	0	3	-0.025	46	0; 
% 	2	0	0	3	-0.025	45  0;
% 	2	0	0	3	-0.020	47	0;
];






